from datetime import datetime, timedelta
from email.utils import formatdate
import os
import json
import logging
import re
from sqlmodel import select
from urllib.parse import unquote, urlparse
from sqlalchemy.exc import SQLAlchemyError

from collections.abc import Callable
from http.cookies import SimpleCookie
from http.server import BaseHTTPRequestHandler
from typing import Self

from pydantic import ValidationError
from sqlmodel import Session

from back.config import (
    engine, TEMPLATE_ENVIRONMENT, STATIC_URL, DEFAULT_URL,
    APPLICATION_JSON, APPLICATION_URLENCODED,
)
from back.models import User, RegistrationForm
from back.custom_types import Request, Response
from back.utils import BadUserError, UserIsNotAuthenticated, check_token, clear_cookie, generate_login, generate_password, generate_token
from back.validators import RegistrationFormModel

FRONTEND_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "front"))

class HTTPHandler(BaseHTTPRequestHandler):
    paths = {"GET": {}, "POST": {}, "PUT": {}, "DELETE": {}}

    def parse_request(self) -> bool:
        result = super().parse_request()
        parse = urlparse(self.path)
        self.path = parse.path
        self.query = parse.query
        return result

    def __init__(self, *args, **kwargs):
        with Session(engine) as self.session:
            super().__init__(*args, **kwargs)

    def req(self) -> Request:
        headers = dict(self.headers)
        cookie = SimpleCookie(headers.get("Cookie", ""))
        length = int(headers.get("Content-Length", 0))
        body = self.rfile.read(length) if length else b""
        method = self.command
        return Request(
            headers=headers,
            cookie=cookie,
            method=method,
            path=self.path,
            query=self.query,
            body=body,
        )

    def resp(self, response: Response):
        self.send_response(response.status)
        for name, value in response.headers.items():
            self.send_header(name, value)
        for name in response.cookie:
            response.cookie[name]["path"] = DEFAULT_URL
            self.send_header("Set-Cookie", response.cookie[name].OutputString())
        self.end_headers()
        if response.content:
            if isinstance(response.content, bytes):
                self.wfile.write(response.content)
            else:
                self.wfile.write(response.content.encode())

    def do_GET(self):
        if self.path.startswith("/front/"):
            self.serve_static()
            return
        try:
            self.paths["GET"][self.path](self)
        except KeyError:
            self.send_error(404, explain=f"Page {self.path} not found")
        except Exception as e:
            logging.error(str(e))
            self.send_error(500)

    def do_POST(self):
        if self.path.startswith("/front/"):
            self.send_error(404)
            return
        try:
            self.paths["POST"][self.path](self)
        except KeyError:
            self.send_error(404, explain="Invalid URL")
        except Exception as e:
            logging.error(str(e))
            self.send_error(500)

    def do_PUT(self):
        if self.path.startswith("/front/"):
            self.send_error(404)
            return
        try:
            self.paths["PUT"][self.path](self)
        except KeyError:
            self.send_error(404, explain="Invalid URL")
        except Exception as e:
            logging.error(str(e))
            self.send_error(500)

    def serve_static(self):
        relative_path = unquote(self.path.lstrip('/'))
        parts = relative_path.split('/')
        if parts[0] == "front":
            parts = parts[1:]
        full_path = os.path.join(FRONTEND_ROOT, *parts)
        if not os.path.isfile(full_path):
            self.send_error(404, "File not found")
            return
        import mimetypes
        mimetype, _ = mimetypes.guess_type(full_path)
        mimetype = mimetype or "application/octet-stream"
        self.send_response(200)
        self.send_header("Content-Type", mimetype)
        self.end_headers()
        with open(full_path, 'rb') as f:
            self.wfile.write(f.read())

    @classmethod
    def route(cls, methods: list[str], path: str, redirect: str = DEFAULT_URL) -> Callable:
        def decorator(function: Callable) -> Callable:
            def inner(self: Self):
                from back.kwargs import get_kwargs, validation_error_response
                try:
                    kwargs = get_kwargs(function, self)
                    response = function(**kwargs)
                except ValidationError as e:
                    response = validation_error_response(self, redirect, e)
                except Exception as e:
                    logging.exception('Internal server error')
                    content_type = self.headers.get("Content-Type", "")
                    if APPLICATION_JSON in content_type:
                        response = Response(
                            status=400,
                            cookie=SimpleCookie(),
                            headers={"Content-Type": "application/json"},
                            content=json.dumps({"form": str(e)}),
                        )
                    else:
                        response = Response(
                            status=500,
                            cookie=SimpleCookie(),
                            headers={"Content-Type": "text/plain"},
                            content="Internal Server Error",
                        )
                self.resp(response)
                return
            for method in methods:
                cls.paths[method][path] = inner
            return inner
        return decorator



@HTTPHandler.route(["GET"], "/")
def main_page(request: Request) -> Response:
    cookie = request.cookie
    form_data = {}
    errors = {}
    success = cookie.get("success", "").value if "success" in cookie else "0"
    login = cookie.get("login", "").value if "login" in cookie else ""
    password = cookie.get("password", "").value if "password" in cookie else ""

    # Очищаем куки только после их использования
    if success == "1" and login and password:
        cleared_cookies = SimpleCookie()
        cleared_cookies["success"] = "0"
        cleared_cookies["login"] = ""
        cleared_cookies["password"] = ""
        for key in cleared_cookies:
            cleared_cookies[key]["expires"] = 0
    else:
        cleared_cookies = cookie

    for field in ["child_name", "child_birthdate", "parent_name", "phone", "email", "comment", "consent"]:
        if field in cookie:
            form_data[field] = cookie[field].value if isinstance(cookie[field], SimpleCookie) else ""
        if field + "_err" in cookie:
            errors[field] = cookie[field + "_err"].value if isinstance(cookie[field + "__err"], SimpleCookie) else ""

    content = TEMPLATE_ENVIRONMENT.get_template("index.html").render(
        form_data=form_data,
        errors=errors,
        success=success,
        login=login,
        password=password,
        STATIC_URL=STATIC_URL,
        DEFAULT_URL=DEFAULT_URL
    )
    return Response(200, {"Content-Type": "text/html"}, cleared_cookies, content)

@HTTPHandler.route(["GET"], "/login")
def login_page(request: Request) -> Response:
    content = TEMPLATE_ENVIRONMENT.get_template("login.html").render(
        errors={},
        form_data={},
        STATIC_URL=STATIC_URL,
        DEFAULT_URL=DEFAULT_URL
    )
    return Response(200, {"Content-Type": "text/html"}, SimpleCookie(), content)

@HTTPHandler.route(["POST"], "/")
def handle_form_submission(request: Request, session: Session) -> Response:
    cookie = request.cookie.copy()
    if not isinstance(cookie, SimpleCookie):
        temp = SimpleCookie()
        temp.load(cookie)
        cookie = temp

    errors = {}
    form_data = {}
    content_type = request.headers.get("Content-Type", "")

    try:
        if APPLICATION_JSON in content_type:
            data = json.loads(request.body.decode())
        elif APPLICATION_URLENCODED in content_type:
            from urllib.parse import parse_qs
            data_raw = request.body.decode()
            data = {k: v[0] for k, v in parse_qs(data_raw).items()}
        else:
            data = {}

        form_data = data.copy()
        reg_form = RegistrationFormModel(**data)

        login = generate_login()
        password_plain = generate_password()
        user = User.create(session, login, password_plain)

        RegistrationForm.create(session, reg_form, user)

        # Сохраняем логин и пароль в куки
        cookie["login"] = login
        cookie["login"]["expires"] = formatdate((datetime.now() + timedelta(days=1)).timestamp(), usegmt=True)
        cookie["password"] = password_plain
        cookie["password"]["expires"] = formatdate((datetime.now() + timedelta(days=1)).timestamp(), usegmt=True)
        cookie["success"] = "1"

        # Логирование для отладки
        logging.info(f"Куки установлены: login={login}, password={password_plain}")

        if APPLICATION_JSON in content_type:
            response_data = {
                "login": login,
                "password": password_plain,
                "message": "Регистрация прошла успешно",
            }
            return Response(
                200,
                {"Content-Type": APPLICATION_JSON},
                cookie,
                json.dumps(response_data)
            )
        else:
            return Response(
                303,
                {"Location": "/#registration-form"},
                cookie,
                ""
            )

    except ValidationError as e:
        errors = {err["loc"][0]: err["msg"] for err in e.errors()}
        if APPLICATION_JSON in content_type:
            return Response(
                400,
                {"Content-Type": APPLICATION_JSON},
                cookie,
                json.dumps({"errors": errors})
            )
        else:
            content = TEMPLATE_ENVIRONMENT.get_template("index.html").render(
                form_data=form_data, errors=errors, STATIC_URL=STATIC_URL, DEFAULT_URL=DEFAULT_URL
            )
            return Response(400, {"Content-Type": "text/html"}, cookie, content)

    except Exception as e:
        logging.exception("CRITICAL ERROR on form submit!")
        if APPLICATION_JSON in content_type:
            return Response(
                400,
                {"Content-Type": APPLICATION_JSON},
                cookie,
                json.dumps({"form": str(e)})
            )
        else:
            content = TEMPLATE_ENVIRONMENT.get_template("index.html").render(
                form_data=form_data, errors={"form": str(e)}, STATIC_URL=STATIC_URL, DEFAULT_URL=DEFAULT_URL
            )
            return Response(400, {"Content-Type": "text/html"}, cookie, content)
        

@HTTPHandler.route(["POST"], "/login")
def login_user(request: Request, session: Session) -> Response:
    content_type = request.headers.get("Content-Type", "")
    data = {}

    if APPLICATION_JSON in content_type:
        data = json.loads(request.body.decode())
    elif APPLICATION_URLENCODED in content_type:
        from urllib.parse import parse_qs
        data_raw = request.body.decode()
        data = {k: v[0] for k, v in parse_qs(data_raw).items()}
    else:
        data = {}

    login = (data.get("login") or "").strip()
    password = data.get("password") or ""

    form_data = {"login": login}
    errors = {}

    # Проверяем наличие пользователя и корректность пароля
    user = session.exec(select(User).where(User.login == login)).first()
    if not user or not user.check_password(password):
        errors["form"] = "Неверный логин или пароль"

        # AJAX — вернём json ошибки
        if APPLICATION_JSON in content_type:
            return Response(
                401, {"Content-Type": APPLICATION_JSON}, SimpleCookie(),
                json.dumps(errors)
            )
        # Страница/POST — вернём login.html с ошибкой  
        else:
            content = TEMPLATE_ENVIRONMENT.get_template("login.html").render(
                errors=errors,
                form_data=form_data,
                STATIC_URL=STATIC_URL,
                DEFAULT_URL=DEFAULT_URL
            )
            return Response(
                401, {"Content-Type": "text/html"}, SimpleCookie(), content
            )

    # Создаем токен и сохраняем его в куки
    token = generate_token(user.id, session)
    cookie = SimpleCookie()
    cookie["auth_token"] = token
    cookie["auth_token"]["path"] = "/"

    if APPLICATION_JSON in content_type:
        return Response(
            200,
            {"Content-Type": APPLICATION_JSON},
            cookie,
            json.dumps({"success": True, "redirect": f"/edit?user_id={user.id}"})  # Добавили user_id в URL
        )
    else:
        return Response(
            303,
            {"Location": f"/edit?user_id={user.id}"},  # Добавили user_id в URL
            cookie,
            ""
        )
        
@HTTPHandler.route(["GET"], "/edit")
def edit_form_page(request: Request, session: Session) -> Response:
    auth_token = request.cookie.get("auth_token")
    user_id = check_token({"Authorization": f"Bearer {auth_token.value}"}, session) if auth_token else None
    if not user_id:
        return Response(302, {"Location": "/login"}, SimpleCookie(), "")

    user = session.get(User, user_id)
    if not user:
        return Response(302, {"Location": "/login"}, SimpleCookie(), "")

    try:
        reg_form = session.exec(select(RegistrationForm).where(RegistrationForm.user_id == user_id)).first()
        form_data = reg_form.__dict__ if reg_form else {}
    except Exception:
        form_data = {}

    content = TEMPLATE_ENVIRONMENT.get_template("edit.html").render(
        form_data=form_data, errors={}, STATIC_URL=STATIC_URL, DEFAULT_URL=DEFAULT_URL
    )
    return Response(200, {"Content-Type": "text/html"}, SimpleCookie(), content)

@HTTPHandler.route(["POST", "PUT"], "/edit")
def edit_form_submit(request: Request, session: Session) -> Response:
    auth_token = request.cookie.get("auth_token")
    user_id = check_token({"Authorization": f"Bearer {auth_token.value}"}, session) if auth_token else None
    if not user_id:
        return Response(302, {"Location": "/login"}, SimpleCookie(), "")

    user = session.get(User, user_id)
    if not user:
        return Response(302, {"Location": "/login"}, SimpleCookie(), "")

    content_type = request.headers.get("Content-Type", "")
    errors = {}

    try:
        if APPLICATION_JSON in content_type:
            data = json.loads(request.body.decode())
        elif APPLICATION_URLENCODED in content_type:
            from urllib.parse import parse_qs
            data_raw = request.body.decode()
            data = {k: v[0] for k, v in parse_qs(data_raw).items()}
        else:
            data = {}

        # Находим форму пользователя и обновляем её
        reg_form = session.exec(select(RegistrationForm).where(RegistrationForm.user_id == user_id)).first()
        if reg_form:
            reg_form.update(session, RegistrationFormModel(**data))

        # Возвращаем успешный ответ
        if APPLICATION_JSON in content_type:
            return Response(
                200,
                {"Content-Type": "application/json"},
                SimpleCookie(),
                json.dumps({"success": True, "message": "Данные успешно обновлены"})
            )
        else:
            content = TEMPLATE_ENVIRONMENT.get_template("edit.html").render(
                form_data=data, errors={}, STATIC_URL=STATIC_URL, DEFAULT_URL=DEFAULT_URL, success_message="Данные успешно обновлены"
            )
            return Response(200, {"Content-Type": "text/html"}, SimpleCookie(), content)

    except ValidationError as e:
        errors = {err["loc"][0]: err["msg"] for err in e.errors()}
        if APPLICATION_JSON in content_type:
            return Response(
                400,
                {"Content-Type": "application/json"},
                SimpleCookie(),
                json.dumps(errors)
            )
        else:
            reg_form = session.exec(select(RegistrationForm).where(RegistrationForm.user_id == user_id)).first()
            form_data = reg_form.__dict__ if reg_form else {}
            content = TEMPLATE_ENVIRONMENT.get_template("edit.html").render(
                form_data=data, errors=errors, STATIC_URL=STATIC_URL, DEFAULT_URL=DEFAULT_URL
            )
            return Response(400, {"Content-Type": "text/html"}, SimpleCookie(), content)

    except Exception as e:
        errors["form"] = str(e)
        if APPLICATION_JSON in content_type:
            return Response(
                400,
                {"Content-Type": "application/json"},
                SimpleCookie(),
                json.dumps(errors)
            )
        else:
            reg_form = session.exec(select(RegistrationForm).where(RegistrationForm.user_id == user_id)).first()
            form_data = reg_form.__dict__ if reg_form else {}
            content = TEMPLATE_ENVIRONMENT.get_template("edit.html").render(
                form_data=data, errors=errors, STATIC_URL=STATIC_URL, DEFAULT_URL=DEFAULT_URL
            )
            return Response(400, {"Content-Type": "text/html"}, SimpleCookie(), content)