from datetime import datetime, timedelta
from email.utils import formatdate
import os
import json
import logging
import re
from sqlmodel import select
from urllib.parse import unquote, urlparse

from collections.abc import Callable
from http.cookies import SimpleCookie
from http.server import BaseHTTPRequestHandler
from typing import Self

from pydantic import ValidationError
from sqlmodel import Session

from back.config import (
    engine, TEMPLATE_ENVIRONMENT, STATIC_URL, DEFAULT_URL,
    APPLICATION_JSON, APPLICATION_URLENCODED,
)
from back.models import User, RegistrationForm
from back.custom_types import Request, Response
from back.utils import BadUserError, UserIsNotAuthenticated, check_token, clear_cookie, generate_login, generate_password, generate_token
from back.validators import RegistrationFormModel

FRONTEND_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "front"))

class HTTPHandler(BaseHTTPRequestHandler):
    paths = {"GET": {}, "POST": {}, "PUT": {}, "DELETE": {}}

    def parse_request(self) -> bool:
        result = super().parse_request()
        parse = urlparse(self.path)
        self.path = parse.path
        self.query = parse.query
        return result

    def __init__(self, *args, **kwargs):
        with Session(engine) as self.session:
            super().__init__(*args, **kwargs)

    def req(self) -> Request:
        headers = dict(self.headers)
        cookie = SimpleCookie(headers.get("Cookie", ""))
        length = int(headers.get("Content-Length", 0))
        body = self.rfile.read(length) if length else b""
        method = self.command
        return Request(
            headers=headers,
            cookie=cookie,
            method=method,
            path=self.path,
            query=self.query,
            body=body,
        )

    def resp(self, response: Response):
        self.send_response(response.status)
        for name, value in response.headers.items():
            self.send_header(name, value)
        for name in response.cookie:
            response.cookie[name]["path"] = DEFAULT_URL
            self.send_header("Set-Cookie", response.cookie[name].OutputString())
        self.end_headers()
        if response.content:
            if isinstance(response.content, bytes):
                self.wfile.write(response.content)
            else:
                self.wfile.write(response.content.encode())

    def do_GET(self):
        if self.path.startswith("/front/"):
            self.serve_static()
            return
        try:
            self.paths["GET"][self.path](self)
        except KeyError:
            self.send_error(404, explain=f"Page {self.path} not found")
        except Exception as e:
            logging.error(str(e))
            self.send_error(500)

    def do_POST(self):
        if self.path.startswith("/front/"):
            self.send_error(404)
            return
        try:
            self.paths["POST"][self.path](self)
        except KeyError:
            self.send_error(404, explain="Invalid URL")
        except Exception as e:
            logging.error(str(e))
            self.send_error(500)

    def serve_static(self):
        relative_path = unquote(self.path.lstrip('/'))
        parts = relative_path.split('/')
        if parts[0] == "front":
            parts = parts[1:]
        full_path = os.path.join(FRONTEND_ROOT, *parts)
        if not os.path.isfile(full_path):
            self.send_error(404, "File not found")
            return
        import mimetypes
        mimetype, _ = mimetypes.guess_type(full_path)
        mimetype = mimetype or "application/octet-stream"
        self.send_response(200)
        self.send_header("Content-Type", mimetype)
        self.end_headers()
        with open(full_path, 'rb') as f:
            self.wfile.write(f.read())


    
    def do_PUT(self):
        if self.path.startswith("/front/"):
            self.send_error(404)
            return
        try:
            # Динамический поиск обработчика с использованием regexp
            matched_routes = [
                (path, handler) for path, handler in self.paths["PUT"].items() 
                if re.match(path, self.path)
            ]
            
            if matched_routes:
                matched_routes[0][1](self)
            else:
                self.send_error(404, explain="Invalid URL")
        except Exception as e:
            logging.error(str(e))
            self.send_error(500)

    def do_DELETE(self):
        """Обработчик DELETE-запросов."""
        if self.path.startswith("/front/"):
            self.send_error(404)
            return
        try:
            self.paths["DELETE"][self.path](self)
        except KeyError:
            self.send_error(404, explain="Invalid URL")
        except Exception as e:
            logging.error(str(e))
            self.send_error(500)

    @classmethod
    def route(cls, methods: list[str], path: str, redirect: str = DEFAULT_URL) -> Callable:
        def decorator(function: Callable) -> Callable:
            def inner(self: Self):
                from back.kwargs import get_kwargs, validation_error_response
                try:
                    kwargs = get_kwargs(function, self)
                    response = function(**kwargs)
                except ValidationError as e:
                    response = validation_error_response(self, redirect, e)
                except Exception as e:
                    logging.exception('Internal server error')
                    content_type = self.headers.get("Content-Type", "")
                    if APPLICATION_JSON in content_type:
                        response = Response(
                            status=400,
                            cookie=SimpleCookie(),
                            headers={"Content-Type": "application/json"},
                            content=json.dumps({"form": str(e)}),
                        )
                    else:
                        response = Response(
                            status=500,
                            cookie=SimpleCookie(),
                            headers={"Content-Type": "text/plain"},
                            content="Internal Server Error",
                        )
                self.resp(response)
                return
            for method in methods:
                cls.paths[method][path] = inner
            return inner
        return decorator


@HTTPHandler.route(["GET"], "/")
def main_page(request: Request) -> Response:
    cookie = request.cookie
    form_data = {}
    errors = {}
    success = cookie.get("success", "").value if "success" in cookie else "0"
    login = cookie.get("login", "").value if "login" in cookie else ""
    password = cookie.get("password", "").value if "password" in cookie else ""

    # Очищаем куки только после их использования
    if success == "1" and login and password:
        cleared_cookies = SimpleCookie()
        cleared_cookies["success"] = "0"
        cleared_cookies["login"] = ""
        cleared_cookies["password"] = ""
        for key in cleared_cookies:
            cleared_cookies[key]["expires"] = 0
    else:
        cleared_cookies = cookie

    for field in ["child_name", "child_birthdate", "parent_name", "phone", "email", "comment", "consent"]:
        if field in cookie:
            form_data[field] = cookie[field].value if isinstance(cookie[field], SimpleCookie) else ""
        if field + "_err" in cookie:
            errors[field] = cookie[field + "_err"].value if isinstance(cookie[field + "__err"], SimpleCookie) else ""

    content = TEMPLATE_ENVIRONMENT.get_template("index.html").render(
        form_data=form_data,
        errors=errors,
        success=success,
        login=login,
        password=password,
        STATIC_URL=STATIC_URL,
        DEFAULT_URL=DEFAULT_URL
    )
    return Response(200, {"Content-Type": "text/html"}, cleared_cookies, content)

@HTTPHandler.route(["GET"], "/login")
def login_page(request: Request) -> Response:
    content = TEMPLATE_ENVIRONMENT.get_template("login.html").render(
        errors={},
        form_data={},
        STATIC_URL=STATIC_URL,
        DEFAULT_URL=DEFAULT_URL
    )
    return Response(200, {"Content-Type": "text/html"}, SimpleCookie(), content)

# Логика для работы с POST-запросами
@HTTPHandler.route(["POST"], "/")
def handle_form_submission(request: Request, session: Session) -> Response:
    cookie = request.cookie.copy()
    if not isinstance(cookie, SimpleCookie):
        temp = SimpleCookie()
        temp.load(cookie)
        cookie = temp

    errors = {}
    form_data = {}
    content_type = request.headers.get("Content-Type", "")

    try:
        if APPLICATION_JSON in content_type:
            data = json.loads(request.body.decode())
        elif APPLICATION_URLENCODED in content_type:
            from urllib.parse import parse_qs
            data_raw = request.body.decode()
            data = {k: v[0] for k, v in parse_qs(data_raw).items()}
        else:
            data = {}

        form_data = data.copy()
        reg_form = RegistrationFormModel(**data)

        login = generate_login()
        password_plain = generate_password()
        user = User.create(session, login, password_plain)

        RegistrationForm.create(session, reg_form, user)

        # Сохраняем логин и пароль в куки
        cookie["login"] = login
        cookie["login"]["expires"] = formatdate((datetime.now() + timedelta(days=1)).timestamp(), usegmt=True)
        cookie["password"] = password_plain
        cookie["password"]["expires"] = formatdate((datetime.now() + timedelta(days=1)).timestamp(), usegmt=True)
        cookie["success"] = "1"

        # Логирование для отладки
        logging.info(f"Куки установлены: login={login}, password={password_plain}")

        if APPLICATION_JSON in content_type:
            response_data = {
                "login": login,
                "password": password_plain,
                "message": "Регистрация прошла успешно",
            }
            return Response(
                200,
                {"Content-Type": APPLICATION_JSON},
                cookie,
                json.dumps(response_data)
            )
        else:
            return Response(
                303,
                {"Location": "/#registration-form"},
                cookie,
                ""
            )

    except ValidationError as e:
        errors = {err["loc"][0]: err["msg"] for err in e.errors()}
        if APPLICATION_JSON in content_type:
            return Response(
                400,
                {"Content-Type": APPLICATION_JSON},
                cookie,
                json.dumps({"errors": errors})
            )
        else:
            content = TEMPLATE_ENVIRONMENT.get_template("index.html").render(
                form_data=form_data, errors=errors, STATIC_URL=STATIC_URL, DEFAULT_URL=DEFAULT_URL
            )
            return Response(400, {"Content-Type": "text/html"}, cookie, content)

    except Exception as e:
        logging.exception("CRITICAL ERROR on form submit!")
        if APPLICATION_JSON in content_type:
            return Response(
                400,
                {"Content-Type": APPLICATION_JSON},
                cookie,
                json.dumps({"form": str(e)})
            )
        else:
            content = TEMPLATE_ENVIRONMENT.get_template("index.html").render(
                form_data=form_data, errors={"form": str(e)}, STATIC_URL=STATIC_URL, DEFAULT_URL=DEFAULT_URL
            )
            return Response(400, {"Content-Type": "text/html"}, cookie, content)
        

@HTTPHandler.route(["POST"], "/login")
def login_user(request: Request, session: Session) -> Response:
    content_type = request.headers.get("Content-Type", "")
    data = {}

    if APPLICATION_JSON in content_type:
        data = json.loads(request.body.decode())
    elif APPLICATION_URLENCODED in content_type:
        from urllib.parse import parse_qs
        data_raw = request.body.decode()
        data = {k: v[0] for k, v in parse_qs(data_raw).items()}
    else:
        data = {}

    login = (data.get("login") or "").strip()
    password = data.get("password") or ""

    form_data = {"login": login}
    errors = {}

    # Проверяем наличие пользователя и корректность пароля
    user = session.exec(select(User).where(User.login == login)).first()
    if not user or not user.check_password(password):
        errors["form"] = "Неверный логин или пароль"

        # AJAX — вернём json ошибки
        if APPLICATION_JSON in content_type:
            return Response(
                401, {"Content-Type": APPLICATION_JSON}, SimpleCookie(),
                json.dumps(errors)
            )
        # Страница/POST — вернём login.html с ошибкой  
        else:
            content = TEMPLATE_ENVIRONMENT.get_template("login.html").render(
                errors=errors,
                form_data=form_data,
                STATIC_URL=STATIC_URL,
                DEFAULT_URL=DEFAULT_URL
            )
            return Response(
                401, {"Content-Type": "text/html"}, SimpleCookie(), content
            )

    # Создаем токен и сохраняем его в куки
    token = generate_token(user.id, session)
    cookie = SimpleCookie()
    cookie["auth_token"] = token
    cookie["auth_token"]["path"] = "/"

    # AJAX — вернём JSON с токеном
    if APPLICATION_JSON in content_type:
        return Response(
            200, {"Content-Type": APPLICATION_JSON}, cookie,
            json.dumps({"success": True, "redirect": "/edit"})
        )
    # Классическая форма — редирект на /edit
    else:
        return Response(
            303, {"Location": "/edit"}, cookie, ""
        )
        
@HTTPHandler.route(["GET"], "/edit11")
def edit_form_page(request: Request, session: Session) -> Response:
    auth_token = request.cookie.get("auth_token")
    user_id = check_token({"Authorization": f"Bearer {auth_token.value}"}, session) if auth_token else None
    if not user_id:
        return Response(302, {"Location": "/login"}, SimpleCookie(), "")

    user = session.get(User, user_id)
    if not user:
        return Response(302, {"Location": "/login"}, SimpleCookie(), "")

    try:
        reg_form = session.exec(select(RegistrationForm).where(RegistrationForm.user_id == user_id)).first()
        form_data = reg_form.__dict__ if reg_form else {}
    except Exception:
        form_data = {}

    content = TEMPLATE_ENVIRONMENT.get_template("edit.html").render(
        form_data=form_data, errors={}, STATIC_URL=STATIC_URL, DEFAULT_URL=DEFAULT_URL
    )
    return Response(200, {"Content-Type": "text/html"}, SimpleCookie(), content)

@HTTPHandler.route(["GET"], "/edit")
def edit_form_page(request: Request, session: Session) -> Response:
    auth_token = request.cookie.get("auth_token")
    user_id = check_token({"Authorization": f"Bearer {auth_token.value}"}, session) if auth_token else None
    if not user_id:
        return Response(302, {"Location": "/login"}, SimpleCookie(), "")

    user = session.get(User, user_id)
    if not user:
        return Response(302, {"Location": "/login"}, SimpleCookie(), "")

    try:
        reg_form = session.exec(select(RegistrationForm).where(RegistrationForm.user_id == user_id)).first()
        form_data = reg_form.__dict__ if reg_form else {}
    except Exception:
        form_data = {}

    content = TEMPLATE_ENVIRONMENT.get_template("edit.html").render(
        user=user,  # Добавлено
        form_data=form_data, 
        errors={}, 
        STATIC_URL=STATIC_URL, 
        DEFAULT_URL=DEFAULT_URL
    )
    return Response(200, {"Content-Type": "text/html"}, SimpleCookie(), content)


@HTTPHandler.route(["PUT"], r"/edit/\d+")
def edit_form_put(request: Request, session: Session) -> Response:
    # Извлечение user_id из пути
    user_id = int(request.path.split('/')[-1])

    auth_token = request.cookie.get("auth_token")
    authenticated_user_id = check_token({"Authorization": f"Bearer {auth_token.value}"}, session) if auth_token else None
    
    # Проверка аутентификации и прав доступа
    if not authenticated_user_id or authenticated_user_id != user_id:
        return Response(302, {"Location": "/login"}, SimpleCookie(), "")

    content_type = request.headers.get("Content-Type", "")

    try:
        if APPLICATION_JSON in content_type:
            data = json.loads(request.body.decode())
        else:
            return Response(400, {"Content-Type": "application/json"}, SimpleCookie(), 
                            json.dumps({"error": "Unsupported content type"}))

        # Находим и обновляем форму для конкретного пользователя
        reg_form = session.exec(select(RegistrationForm).where(RegistrationForm.user_id == user_id)).first()
        if reg_form:
            reg_form.update(session, RegistrationFormModel(**data))

        return Response(
            200,
            {"Content-Type": APPLICATION_JSON},
            SimpleCookie(),
            json.dumps({"success": True, "message": "Данные успешно обновлены"})
        )

    except ValidationError as e:
        errors = {err["loc"][0]: err["msg"] for err in e.errors()}
        return Response(
            400,
            {"Content-Type": APPLICATION_JSON},
            SimpleCookie(),
            json.dumps(errors)
        )

    except Exception as e:
        return Response(
            500,
            {"Content-Type": APPLICATION_JSON},
            SimpleCookie(),
            json.dumps({"error": str(e)})
        )






@HTTPHandler.route(["POST"], "/edit")
def edit_form_submit(request: Request, session: Session) -> Response:
    auth_token = request.cookie.get("auth_token")
    user_id = check_token({"Authorization": f"Bearer {auth_token.value}"}, session) if auth_token else None
    if not user_id:
        return Response(302, {"Location": "/login"}, SimpleCookie(), "")

    user = session.get(User, user_id)
    if not user:
        return Response(302, {"Location": "/login"}, SimpleCookie(), "")

    content_type = request.headers.get("Content-Type", "")
    errors = {}

    try:
        if APPLICATION_JSON in content_type:
            data = json.loads(request.body.decode())
        elif APPLICATION_URLENCODED in content_type:
            from urllib.parse import parse_qs
            data_raw = request.body.decode()
            data = {k: v[0] for k, v in parse_qs(data_raw).items()}
        else:
            data = {}

        reg_form = session.exec(select(RegistrationForm).where(RegistrationForm.user_id == user_id)).first()
        if reg_form:
            reg_form.update(session, RegistrationFormModel(**data))

        if APPLICATION_JSON in content_type:
            return Response(
                200,
                {"Content-Type": APPLICATION_JSON},
                SimpleCookie(),
                json.dumps({"success": True, "message": "Данные успешно обновлены"})
            )
        else:
            content = TEMPLATE_ENVIRONMENT.get_template("edit.html").render(
                form_data=data, errors={}, STATIC_URL=STATIC_URL, DEFAULT_URL=DEFAULT_URL, success_message="Данные успешно обновлены"
            )
            return Response(200, {"Content-Type": "text/html"}, SimpleCookie(), content)

    except ValidationError as e:
        errors = {err["loc"][0]: err["msg"] for err in e.errors()}
        if APPLICATION_JSON in content_type:
            return Response(
                400,
                {"Content-Type": APPLICATION_JSON},
                SimpleCookie(),
                json.dumps(errors)
            )
        else:
            reg_form = session.exec(select(RegistrationForm).where(RegistrationForm.user_id == user_id)).first()
            form_data = reg_form.__dict__ if reg_form else {}
            content = TEMPLATE_ENVIRONMENT.get_template("edit.html").render(
                form_data=data, errors=errors, STATIC_URL=STATIC_URL, DEFAULT_URL=DEFAULT_URL
            )
            return Response(400, {"Content-Type": "text/html"}, SimpleCookie(), content)

    except Exception as e:
        errors["form"] = str(e)
        if APPLICATION_JSON in content_type:
            return Response(
                400,
                {"Content-Type": APPLICATION_JSON},
                SimpleCookie(),
                json.dumps(errors)
            )
        else:
            reg_form = session.exec(select(RegistrationForm).where(RegistrationForm.user_id == user_id)).first()
            form_data = reg_form.__dict__ if reg_form else {}
            content = TEMPLATE_ENVIRONMENT.get_template("edit.html").render(
                form_data=data, errors=errors, STATIC_URL=STATIC_URL, DEFAULT_URL=DEFAULT_URL
            )
            return Response(400, {"Content-Type": "text/html"}, SimpleCookie(), content)










# Улучшение сообщений об ошибках и оптимизация обработки валидации

## 1. Устранение "Value error" и улучшение сообщений об ошибках

Чтобы убрать префикс "Value error," из сообщений об ошибках и улучшить стандартные сообщения для пустых полей, нужно обновить обработку ошибок валидации в обработчике и добавить дополнительные валидаторы в Pydantic-модель.

### Обновление validators.py:

```python
import re
from typing import Optional
from datetime import date

from pydantic import BaseModel, EmailStr, validator, Field

class RegistrationFormModel(BaseModel):
    # Используем Field для задания подробных сообщений об ошибках
    child_name: str = Field(..., description="ФИО ребёнка", title="ФИО ребёнка")
    child_birthdate: str = Field(..., description="Дата рождения ребёнка", title="Дата рождения")
    parent_name: str = Field(..., description="ФИО родителя", title="ФИО родителя")
    phone: str = Field(..., description="Телефон", title="Телефон")
    email: EmailStr = Field(..., description="Электронная почта", title="Электронная почта")
    comment: Optional[str] = Field(None, description="Комментарий", title="Комментарий")
    consent: bool = Field(..., description="Согласие на обработку данных", title="Согласие")

    # Проверка на пустые поля с пользовательскими сообщениями
    @validator("child_name", "parent_name", "phone", "email", "child_birthdate", pre=True)
    def check_not_empty(cls, v, values, **kwargs):
        field_name = kwargs["field"].name
        if not v or (isinstance(v, str) and not v.strip()):
            field_title = kwargs["field"].field_info.title
            raise ValueError(f"Пожалуйста, заполните поле {field_title}")
        return v

    @validator("child_name", "parent_name")
    def valid_name(cls, v: str) -> str:
        v = v.strip()
        if not re.match(r"^[A-Za-zА-Яа-яЁё\s\-]+$", v):
            return "Имя должно содержать только буквы"
        return v

    @validator("child_birthdate")
    def valid_birthdate(cls, v: str) -> str:
        try:
            parts = v.split("-")
            if len(parts) != 3:
                raise ValueError()
            year, month, day = map(int, parts)
            bdate = date(year, month, day)
        except Exception:
            return "Неверный формат даты рождения. Используйте ГГГГ-ММ-ДД"
        today = date.today()
        age = (today - bdate).days // 365
        if age < 6 or age > 8:
            return "Возраст ребёнка должен быть от 6 до 8 лет"
        return v

    @validator("phone")
    def valid_phone(cls, v: str) -> str:
        # Очищаем от всех не-цифр
        digits_only = ''.join(filter(str.isdigit, v))
        
        # Проверяем общую длину
        if len(digits_only) != 11:
            return "Номер телефона должен содержать 11 цифр"
        
        # Проверяем начало номера (должен начинаться с 7 или 8)
        if not (digits_only.startswith('7') or digits_only.startswith('8')):
            return "Номер должен начинаться с 7 или 8"
        
        # Допустим несколько форматов записи для удобства
        pattern = r'^(\+7|7|8)[\s\-]?\(?[9]\d{2}\)?[\s\-]?\d{3}[\s\-]?\d{2}[\s\-]?\d{2}$'
        if not re.match(pattern, v):
            return "Неверный формат телефона. Пример: +7 (999) 123-45-67"
        
        return v

    @validator("consent")
    def consent_must_be_true(cls, v: bool) -> bool:
        if v is not True:
            return "Требуется согласие на обработку данных"
        return v
```

### Обновление обработки ValidationError в handler.py:

```python
except ValidationError as e:
    # Обработка ошибок валидации без префикса "Value error"
    errors = {}
    for err in e.errors():
        loc = err["loc"][0]  # Название поля
        msg = err["msg"]
        
        # Убираем префикс "Value error: " если он есть
        if msg.startswith("Value error: "):
            msg = msg[13:]  # Длина "Value error: "
        
        # Для ошибок field required используем кастомное сообщение
        if msg == "field required":
            field_info = RegistrationFormModel.model_fields.get(loc)
            field_title = getattr(field_info, "title", loc) if field_info else loc
            msg = f"Пожалуйста, заполните поле {field_title}"
        
        errors[loc] = msg
        
    # Остальной код без изменений...
```

## 2. Оптимизированная обработка ошибок и ввода формы

### Создание вспомогательных функций для обработки данных:

Добавьте в utils.py следующие вспомогательные функции:

```python
def normalize_form_data(data, current_data=None):
    """
    Нормализует данные формы для отображения в шаблоне.
    Объединяет текущие данные с новыми и преобразует типы.
    """
    result = {}
    
    # Копируем текущие данные, если есть
    if current_data:
        result.update(current_data)
    
    # Обновляем новыми данными
    if data:
        result.update(data)
    
    # Обрабатываем специальные случаи
    if 'consent' in result:
        if isinstance(result['consent'], str):
            result['consent'] = result['consent'].lower() in ('true', 'on', '1', 'yes')
    
    # Удаляем технические поля SQLModel
    if '_sa_instance_state' in result:
        del result['_sa_instance_state']
    
    return result

def process_validation_errors(validation_error):
    """
    Обрабатывает ошибки валидации Pydantic для лучшего отображения.
    """
    errors = {}
    for err in validation_error.errors():
        loc = err["loc"][0]  # Название поля
        msg = err["msg"]
        
        # Убираем префикс "Value error: " если он есть
        if msg.startswith("Value error: "):
            msg = msg[13:]
        
        # Для ошибок field required используем кастомное сообщение
        if msg == "field required":
            field_info = RegistrationFormModel.model_fields.get(loc)
            field_title = getattr(field_info, "title", loc) if field_info else loc
            msg = f"Пожалуйста, заполните поле {field_title}"
        
        errors[loc] = msg
    
    return errors
```

### Обновление обработчиков с использованием этих функций:

```python
@HTTPHandler.route(["PUT", "POST"], "/users/{id}")
def update_user_data(request: Request, session: Session) -> Response:
    # ... код до получения данных ...
    
    # Получаем текущие данные из базы
    try:
        current_form = session.exec(select(RegistrationForm).where(RegistrationForm.user_id == user_id)).first()
        current_data = current_form.__dict__ if current_form else {}
    except Exception:
        current_data = {}
    
    try:
        # Получаем данные из запроса
        if is_ajax:
            form_data = json.loads(request.body.decode())
        elif APPLICATION_URLENCODED in content_type:
            from urllib.parse import parse_qs
            data_raw = request.body.decode()
            form_data = {k: v[0] for k, v in parse_qs(data_raw).items()}
            
            # Особая обработка для checkbox
            if 'consent' not in form_data and request.method != "GET":
                form_data['consent'] = False
        else:
            form_data = {}
        
        # Нормализуем данные
        processed_data = normalize_form_data(form_data)
        
        # Валидируем данные
        validated_data = RegistrationFormModel(**processed_data)
        
        # Обновляем запись в базе
        if current_form:
            current_form.update(session, validated_data)
        
        # Рендерим ответ...
        
    except ValidationError as e:
        # Обрабатываем ошибки валидации
        errors = process_validation_errors(e)
        
        if is_ajax:
            return Response(
                400,
                {"Content-Type": APPLICATION_JSON},
                SimpleCookie(),
                json.dumps({"errors": errors})
            )
        else:
            # Нормализуем данные, сохраняя введенные пользователем значения
            merged_data = normalize_form_data(form_data, current_data)
            
            content = TEMPLATE_ENVIRONMENT.get_template("edit.html").render(
                form_data=merged_data,
                errors=errors,
                STATIC_URL=STATIC_URL,
                DEFAULT_URL=DEFAULT_URL,
                user_id=user_id
            )
            return Response(400, {"Content-Type": "text/html"}, SimpleCookie(), content)
    
    # ... обработка других исключений ...
```

## 3. Оптимизированная реализация validators.py с использованием model_validator

Для еще большей оптимизации и удобства можно использовать `model_validator` в Pydantic v2:

```python
from pydantic import BaseModel, EmailStr, Field, field_validator, model_validator
from typing import Optional, Dict, Any
from datetime import date
import re

class RegistrationFormModel(BaseModel):
    child_name: str = Field(..., description="ФИО ребёнка", title="ФИО ребёнка")
    child_birthdate: str = Field(..., description="Дата рождения ребёнка", title="Дата рождения")
    parent_name: str = Field(..., description="ФИО родителя", title="ФИО родителя")
    phone: str = Field(..., description="Телефон", title="Телефон")
    email: EmailStr = Field(..., description="Электронная почта", title="Электронная почта")
    comment: Optional[str] = Field(None, description="Комментарий", title="Комментарий")
    consent: bool = Field(..., description="Согласие на обработку данных", title="Согласие")
    
    @model_validator(mode='before')
    @classmethod
    def check_empty_fields(cls, data: Dict[str, Any]) -> Dict[str, Any]:
        """Проверяет пустые поля и приводит их к правильному типу."""
        if not isinstance(data, dict):
            return data
            
        # Проверяем пустые поля
        required_fields = {
            'child_name': 'ФИО ребёнка',
            'child_birthdate': 'Дата рождения ребёнка',
            'parent_name': 'ФИО родителя',
            'phone': 'Телефон',
            'email': 'Электронная почта',
            'consent': 'Согласие на обработку данных'
        }
        
        for field, title in required_fields.items():
            if field not in data or (isinstance(data.get(field), str) and not data[field].strip()):
                raise ValueError(f"{field}: Пожалуйста, заполните поле {title}")
        
        # Обработка consent
        if 'consent' in data and not isinstance(data['consent'], bool):
            data['consent'] = str(data['consent']).lower() in ('true', 'on', '1', 'yes')
            
        return data
    
    # Остальные валидаторы как раньше...
```

Эти изменения существенно оптимизируют обработку данных формы и улучшают сообщения об ошибках для пользователя, особенно при отключенном JavaScript.